[{"title":"Redis数据类型","date":"2021-05-14T08:13:00.000Z","path":"2021/05/14/Redis数据类型/","text":"Redis是什么 Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器 Redis与其他key-value缓存产品有以下三个特点 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis是单线程 Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了 String （字符串类型） String是redis最基本的类型，一个key对应一个value。 String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。 String类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。 List(列表) Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 它的底层实际是个链表 ! Hash（哈希) Redis hash 是一个键值对集合。 Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。 Set（集合） Redis的Set是String类型的无序集合，它是通过HashTable实现的 Zset（sorted set：有序集合） Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。 Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）却可以重复。 在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2 GEO地理位置 Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。 GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash官方文档：https://www.redis.net.cn/order/3685.html HyperLogLog Redis 在 2.8.9 版本添加了 HyperLogLog 结构。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 BitMap BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个bitmap 相关命令。","link":"","tags":[{"name":"redis","slug":"redis","permalink":"https://holmexin.github.io/tags/redis/"}]},{"title":"NoSQL概述","date":"2021-05-14T07:59:37.000Z","path":"2021/05/14/NoSQL概述/","text":"为什么用NoSQL 今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大的数据。 NoSQL特点 1、易扩展 NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。 2、大数据量高性能 NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系性，数据库的结构简单。 一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。 官方记录：Redis 一秒可以写8万次，读11万次 3、多样灵活的数据模型 NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦。 四大分类 KV键值：redis 文档型数据库(bson格式比较多)： MongoDB MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 列存储数据库 图关系数据库","link":"","tags":[{"name":"redis","slug":"redis","permalink":"https://holmexin.github.io/tags/redis/"}]},{"title":"Git版本控制","date":"2021-05-14T06:25:25.000Z","path":"2021/05/14/Git版本控制/","text":"git和SVN Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git是目前世界上最先进的分布式版本控制系统。 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 git配置 查看配置 git config -l 查看不同级别的配置文件： 12345#查看系统configgit config --system --list#查看当前用户（global）配置git config --global --list 设置用户名和邮箱（用户标识，必要） 当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： 12git config --global user.name &quot;holmexin&quot; #名称git config --global user.email 123456789@qq.com #邮箱 只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。 总之–global为全局配置，不加为某个项目的特定配置 常用指令 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 1、创建全新的仓库，需要用GIT管理的项目的根目录执行： 12# 在当前目录新建一个Git代码库$ git init 2、执行后仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地 12# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url] 文件操作 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过 git add状态变为 Staged Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为 Modified . 如果使用 git rm 移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过 git add 可进入暂存 staged 状态, 使用 git checkout 则丢弃修改, 返回到 unmodify 状态,这个 git checkout 即从库中取出文件, 覆盖当前修改 Staged: 暂存状态. 执行 git commit 则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为 Unmodify 状态. 执行 git reset HEAD filename 取消暂存, 文件状态为Modified 12345678910#查看指定文件状态git status [filename]#查看所有文件状态git statusgit add .git commitgit remote add origin [URL]git push -u origin master 其他 123456789101112131415161718192021222324# 检查冲突git rebase# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。","link":"","tags":[{"name":"git","slug":"git","permalink":"https://holmexin.github.io/tags/git/"}]},{"title":"Linux笔记","date":"2021-05-14T01:58:10.000Z","path":"2021/05/14/Linux笔记/","text":"目录结构 /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 常用命令 处理目录 ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 ls 选项与参数：(可组合使用) -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) rm 1rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息 -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除 基本属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 文件内容查看Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示 nl 显示的时候，顺道输出行号 more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页 head 只看头几行 tail 只看尾巴几行 可以使用 man [命令]来查看各个命令的使用文档，如 ：man cp less less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关) N ：反向的重复前一个搜寻 (与 / 或 ? 有关) q ：离开 less 这个程序 Linux链接 硬连接 硬连接指通过索引节点来进行连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 VimVim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式： 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 进程管理 概述 1、在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。 2、每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。 3、 每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 4、一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束 ps 使用ps指令即可查看当前系统中正在执行的进程的各种进程信息 基本语法 ps –选项 选项说明： -a：显示当前终端的所有进程信息 -u：以用户的形式显示进程信息 -x：显示后台进程运行的参数 1ps -aux|grep xxx ，查看某个服务的进程 如，ps -aux|grep mysql 1、grep 命令用于查找文件里符合条件的字符串。 2、命令格式：命令A|命令B，即命令A的正确输出作为命令B的操作对象 使用 ps -ef可查看父进程 ps -ef是以全格式显示当前所有的进程 -e 显示所有进程。-f 全格式。","link":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://holmexin.github.io/tags/Linux/"}]},{"title":"MySQL索引","date":"2021-05-14T01:34:16.000Z","path":"2021/05/14/MySQL索引/","text":"1、索引分类 索引的作用 提高查询速度 确保数据的唯一性 可以加速表和表之间的连接 , 实现表与表之间的参照完整性 使用分组和排序子句进行数据检索时 , 可以显著减少分组和排序的时间 全文检索字段进行搜索优化. 分类 主键索引 (Primary Key) 唯一索引 (Unique) 常规索引 (Index) 全文索引 (FullText) 2、主键索引主键 : 某一个属性组能唯一标识一条记录 特点 : 最常见的索引类型 确保数据记录的唯一性 确定特定数据记录在数据库中的位置 12345CREATE TABLE `Grade`(`GradeID` INT(11) AUTO_INCREMENT PRIMARYKEY,`GradeName` VARCHAR(32) NOT NULL UNIQUE// 或 UNIQUE KEY `GradeID` (`GradeID`)) 3、唯一索引作用 : 避免同一个表中某数据列中的值重复 与主键索引的区别 主键索引只能有一个 唯一索引可能有多个 4、常规索引作用 : 快速定位特定数据 注意 : index 和 key 关键字都可以设置常规索引 应加在查询找条件的字段 不宜添加太多常规索引,影响数据的插入,删除和修改操作 1234567CREATE TABLE `result`( // 省略一些代码INDEX/KEY `ind` (`studentNo`,`subjectNo`) // 创建表时添加) // 创建后添加ALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`); 5、全文索引百度搜索：全文索引 作用 : 快速定位特定数据 注意 : 只能用于MyISAM类型的数据表 只能用于CHAR , VARCHAR , TEXT数据列类型 适合大型数据集 6、索引准则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表建议不要加索引 索引一般应加在查找条件的字段 7、三大范式第一范式 (1st NF) 第一范式的目标是确保每列的原子性,如果每列都是不可再分的最小数据单元,则满足第一范式 第二范式(2nd NF) 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF） 第二范式要求每个表只描述一件事情 第三范式(3rd NF) 如果一个关系满足第二范式,并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关","link":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://holmexin.github.io/tags/MySQL/"}]},{"title":"MySQL事务","date":"2021-05-13T13:10:46.000Z","path":"2021/05/13/MySQL事务/","text":"1、概述 什么是事务 事务就是将一组SQL语句放在同一批次内去执行 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行 MySQL事务处理只支持InnoDB和BDB数据表类型 ACID 特性 原子性(Atomic) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consist) 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 隔离性(Isolated) 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性(Durable) 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 2、事务实现基本语法： 123456789101112131415161718192021222324// 使用set语句来改变自动提交模式SET autocommit = 0; /*关闭*/SET autocommit = 1; /*开启*/// 注意://- 1.MySQL中默认是自动提交//- 2.使用事务时应先关闭自动提交 // 开始一个事务,标记事务的起始点START TRANSACTION// 提交一个事务给数据库COMMIT // 将事务回滚,数据回到本次事务的初始状态ROLLBACK // 还原MySQL数据库的自动提交SET autocommit =1;// 保存点SAVEPOINT 保存点名称 // 设置一个事务保存点ROLLBACK TO SAVEPOINT 保存点名称 // 回滚到保存点RELEASE SAVEPOINT 保存点名称 // 删除保存点 12345678// 转账实现SET autocommit = 0; // 关闭自动提交START TRANSACTION; // 开始一个事务,标记事务的起始点UPDATE account SET cash=cash-500 WHERE `name`=&#x27;A&#x27;;UPDATE account SET cash=cash+500 WHERE `name`=&#x27;B&#x27;;COMMIT; // 提交事务// rollback;SET autocommit = 1; // 恢复自动提交","link":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://holmexin.github.io/tags/MySQL/"}]},{"title":"MySQL常用命令","date":"2021-05-13T12:32:39.000Z","path":"2021/05/13/MySQL常用命令/","text":"MySQL是现在流行的开源的，免费的关系型数据库。由瑞典MySQLAB 公司开发，目前属于 Oracle 旗下产品。 官网：https://www.mysql.com/ 1、添加数据 INSERT 123456INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;)INSERT INTO grade(gradename) VALUES (&#x27;大一&#x27;);// 一次插入多条数据INSERT INTO grade(gradename) VALUES (&#x27;大三&#x27;),(&#x27;大四&#x27;); 2、修改数据 UPDATE 123456789UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHEREcondition];// column_name 为要更改的数据列// value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果// condition 为筛选条件 , 如不指定则修改该表的所有列数据// 修改年级信息UPDATE grade SET gradename = &#x27;高中&#x27; WHERE gradeid = 1; 3、删除数据 DELETE 1234DELETE FROM 表名 [WHERE condition];// 删除最后一个数据DELETE FROM grade WHERE gradeid = 5 4、查询数据 SELECT 12345678910SELECT [ALL | DISTINCT]&#123;* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125;FROM table_name [as table_alias][left | right | inner join table_name2] // 联合查询[WHERE ...] // 指定结果需满足的条件[GROUP BY ...] // 指定结果按照哪几个字段来分组[HAVING] // 过滤分组的记录必须满足的次要条件[ORDER BY ...] // 指定查询记录按一个或多个条件排序[LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;];// 指定查询的记录从哪条至哪条","link":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://holmexin.github.io/tags/MySQL/"}]},{"title":"Hello World","date":"2021-05-12T08:10:11.559Z","path":"2021/05/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[]}]